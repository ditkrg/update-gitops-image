name: "Hello World"
description: "Prints hello world"
inputs:
  owner:
    description: "Owner of the repository if it is not the current one"
    default: ${{ github.repository_owner }}
    required: true

  repo:
    description: "Repository on which to update the image tag"
    required: true

  image-tag:
    description: "The tag of the image to be updated"
    required: true

  app-id:
    description: "The id of the GitHub App"
    required: true

  private-key:
    description: "The private key of the GitHub App"
    required: true

  component-name:
    description: "The directory the component manifests are in"
    required: true

author: DIT KRG

runs:
  using: "composite"

  steps:
    - name: Generate token
      id: generate-token
      uses: actions/create-github-app-token@v1
      with:
        app-id: ${{ inputs.app-id }}
        private-key: ${{ inputs.private-key }}
        owner: ${{ inputs.owner }}
        repositories: ${{ inputs.repo }}

    - name: Checkout target repository
      uses: actions/checkout@v4
      with:
        repository: ${{ inputs.owner }}/${{ inputs.repo }} # Replace with the actual target repository
        token: ${{ steps.generate-token.outputs.token }} # insert the token

    - name: Get environment
      id: get-environment
      shell: bash
      run: |

        if [[ $GITHUB_REF == refs/tags/* ]]; then
          environment=production
        elif [[ $GITHUB_REF == refs/heads/main ]]; then
          environment=staging
        else
          environment=dev
        fi
        echo "::set-output name=environment::${environment}"

    - name: Find target file
      id: find-target-file
      shell: bash
      env:
        TARGET_ENV: ${{ steps.get-environment.outputs.environment }}
      run: |

        if [ $TARGET_ENV == "production" ]; then
          target_file="overlays/production/image.yaml"
        elif [ $TARGET_ENV == "staging" ]; then
          target_file="overlays/staging/image.yaml"
        else
          target_file="overlays/development/image.yaml"
        fi

        echo "::set-output name=target_file::${target_file}"

    - name: Create label
      id: create-label
      shell: bash
      env:
        REPO: ${{ inputs.owner }}/${{ inputs.repo }}
        # Define the label you want to check and create if it doesn't exist
        LABEL_NAME: auto-deploy
        # You can specify a color in hexadecimal format
        LABEL_COLOR: 00FF00
        # You can specify a color in hexadecimal format
        LABEL_DESCRIPTION: "This label is used to automatically close a pr when the deployment is done"
        # Set GH_TOKEN
        GH_TOKEN: ${{ steps.generate-token.outputs.token }}

      run: gh label create "$LABEL_NAME" --force --color "$LABEL_COLOR" --description "$LABEL_DESCRIPTION"

    - name: Create branch if not exists
      shell: bash
      env:
        TARGET_BRANCH: update-${{ steps.get-environment.outputs.environment }}-${{ inputs.component-name }}
      run: |

        # Do not create a new branch if the branch already exists
        if [[ $(git ls-remote origin "$TARGET_BRANCH") ]]; then
          git fetch origin
          git checkout "$TARGET_BRANCH"
        else
          git checkout -b "$TARGET_BRANCH"
          git push --set-upstream origin "$TARGET_BRANCH"
        fi

      # Use the REST API to commit changes, so we get automatic commit signing
    - name: Commit changes
      shell: bash
      env:
        GITHUB_TOKEN: ${{ steps.generate-token.outputs.token }}
        TARGET_FILE: ${{ inputs.component-name }}/${{ steps.find-target-file.outputs.target_file }}
        TARGET_BRANCH: update-${{ steps.get-environment.outputs.environment }}-${{ inputs.component-name }}
      run: |

        # Update the image.yaml file with the new image tag
        full_path_image=${{ inputs.image-tag }}
        image_tag_only="${full_path_image##*:}"  # Removes everything up to and including the last colon

        cat >$TARGET_FILE <<EOF
        ---
        ########################################################################################
        # This file was automatically generated by the auto-deploy action. Do not edit manually.#
        ########################################################################################

        image:
          tag: $image_tag_only

        EOF

        export MESSAGE="chore: Update ${{ inputs.component-name }} image tag to $image_tag_only in ${{ steps.get-environment.outputs.environment }}"
        export SHA=$( git rev-parse $TARGET_BRANCH:$TARGET_FILE )
        export CONTENT=$( base64 -i $TARGET_FILE )
        gh api --method PUT /repos/${{ inputs.owner }}/${{ inputs.repo }}/contents/$TARGET_FILE \
          --field message="$MESSAGE" \
          --field content="$CONTENT" \
          --field encoding="base64" \
          --field branch="$TARGET_BRANCH" \
          --field sha="$SHA"

    - name: Create PR and try to merge
      shell: bash
      env:
        GH_TOKEN: ${{ steps.generate-token.outputs.token }}
        LABEL_NAME: auto-deploy
        TARGET_ENV: ${{ steps.get-environment.outputs.environment }}
        TARGET_FILE: ${{ steps.find-target-file.outputs.target_file }}
        HEAD_BRANCH: update-${{ inputs.component-name }}-${{ steps.get-environment.outputs.environment }}

      run: |
        # do not create the PR if it already exists from the same branch
        if [[ $(gh pr list --state open --head $HEAD_BRANCH) ]]; then
          echo "PR already exists"
        else gh pr create \
          --title "chore: Update ${{ inputs.component-name }} image tag to ${{ inputs.image-tag }} in ${{ steps.get-environment.outputs.environment }}" \
          --body "This PR was automatically created by the auto-deploy action. Do not edit manually." \
          --label auto-deploy
        fi
        # gh pr merge --auto --merge "$HEAD_BRANCH" --body "Merge $HEAD_BRANCH into $TARGET_ENV"
