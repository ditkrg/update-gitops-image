name: "Hello World"
description: "Prints hello world"
inputs:
  owner:
    description: "Owner of the repository if it is not the current one"
    default: ${{ github.repository_owner }}
    required: true

  repo:
    description: "Repository on which to update the image tag"
    required: true

  image-tag:
    description: "The tag of the image to be updated"
    required: true

  app-id:
    description: "The id of the GitHub App"
    required: true

  private-key:
    description: "The private key of the GitHub App"
    required: true

  component-name:
    description: "The directory the component manifests are in"
    required: true

  file-template:
    description: "The template of the file to be updated"

  image-tag-path:
    description: "The path to the image tag in the file to be updated"
    default: global.image.tag

author: DIT KRG

runs:
  using: "composite"

  steps:
    - name: Generate token
      id: generate-token
      uses: actions/create-github-app-token@v1
      with:
        app-id: ${{ inputs.app-id }}
        private-key: ${{ inputs.private-key }}
        owner: ${{ inputs.owner }}
        repositories: ${{ inputs.repo }}

    - name: Checkout target repository
      uses: actions/checkout@v4
      with:
        repository: ${{ inputs.owner }}/${{ inputs.repo }} # Replace with the actual target repository
        token: ${{ steps.generate-token.outputs.token }} # insert the token

    - name: Get environment
      id: get-environment
      shell: bash
      run: |

        if [[ $GITHUB_REF == refs/tags/* ]]; then
          environment=production
        elif [[ $GITHUB_REF == refs/heads/main ]]; then
          environment=staging
        else
          environment=dev
        fi
        echo "::set-output name=environment::${environment}"

    - name: Find target file
      id: find-target-file
      shell: bash
      env:
        TARGET_ENV: ${{ steps.get-environment.outputs.environment }}
      run: |

        if [ $TARGET_ENV == "production" ]; then
          target_file="overlays/production/image.yaml"
        elif [ $TARGET_ENV == "staging" ]; then
          target_file="overlays/staging/image.yaml"
        else
          target_file="overlays/development/image.yaml"
        fi

        echo "::set-output name=target_file::${target_file}"

    - name: Create label
      id: create-label
      shell: bash
      env:
        REPO: ${{ inputs.owner }}/${{ inputs.repo }}
        # Define the label you want to check and create if it doesn't exist
        LABEL_NAME: auto-deploy
        # You can specify a color in hexadecimal format
        LABEL_COLOR: 00FF00
        # You can specify a color in hexadecimal format
        LABEL_DESCRIPTION: "This label is used to automatically close a pr when the deployment is done"
        # Set GH_TOKEN
        GH_TOKEN: ${{ steps.generate-token.outputs.token }}

      run: gh label create "$LABEL_NAME" --force --color "$LABEL_COLOR" --description "$LABEL_DESCRIPTION"

    - name: Create branch if not exists
      shell: bash
      env:
        TARGET_FILE: ${{ inputs.component-name }}/${{ steps.find-target-file.outputs.target_file }}
        TARGET_BRANCH: update-${{ steps.get-environment.outputs.environment }}-${{ inputs.component-name }}
      run: |

        # Do not create a new branch if the branch already exists
        if [[ $(git ls-remote origin "$TARGET_BRANCH") ]]; then
          git fetch
          git checkout "$TARGET_BRANCH"
        else
          git checkout -b "$TARGET_BRANCH"
          git push --set-upstream origin "$TARGET_BRANCH"
        fi

        # check if we have conflicts with main
        git fetch
        git rebase $TARGET_BRANCH
        if [ $? -ne 0 ]; then
          git checkout --theirs $TARGET_FILE
          git add $TARGET_FILE
          git rebase --continue
          git push --force
        fi
      # Use the REST API to commit changes, so we get automatic commit signing
    - name: Commit changes
      id: commit
      shell: bash
      env:
        GITHUB_TOKEN: ${{ steps.generate-token.outputs.token }}
        TARGET_FILE: ${{ inputs.component-name }}/${{ steps.find-target-file.outputs.target_file }}
        TARGET_BRANCH: update-${{ steps.get-environment.outputs.environment }}-${{ inputs.component-name }}
      run: |


        echo "#########################################################################################" > $TARGET_FILE
        echo "# This file was automatically generated by the auto-deploy action. Do not edit manually.#" >> $TARGET_FILE
        echo "#########################################################################################\n" >> $TARGET_FILE

        # Update the image.yaml file with the new image tag
        full_path_image=${{ inputs.image-tag }}
        image_tag_only="${full_path_image##*:}"  # Removes everything up to and including the last colon

        # if the file-template is set then use it to create the file else use the image-tag-path
        if [ -n "${{ inputs.file-template }}" ]; then
          echo ${{ inputs.file-template }} >> $TARGET_FILE
        else

        # Define the input path
        input_path="${{ inputs.image-tag-path }}"

        # Split the input path into an array
        IFS='.' read -a path_array <<< "$input_path"

        # Initialize the YAML output
        yaml_output=""

        # Iterate over the path components and build the YAML structure
        for ((i=0; i<${#path_array[@]}; i++)); do
            component="${path_array[$i]}"
            if [ $i -eq $((${#path_array[@]}-1)) ]; then
                yaml_output="${yaml_output}  $component: $image_tag_only\n"
            else
                yaml_output="$yaml_output$component:\n"
                yaml_output="${yaml_output}  "  # Add indentation (two spaces) for nesting
            fi
        done

        echo -e "$yaml_output" >> $TARGET_FILE
        echo -e "$yaml_output"
        fi

        # If the file has not changes then don't commit
        if [[ -z $(git status --porcelain $TARGET_FILE) ]]; then
          echo "::set-output name=commit::false"
          exit 0
        fi
        echo "::set-output name=commit::true"

        export MESSAGE="chore: Update ${{ inputs.component-name }} image tag to $image_tag_only in ${{ steps.get-environment.outputs.environment }}"
        export SHA=$( git rev-parse $TARGET_BRANCH:$TARGET_FILE )
        export CONTENT=$( base64 -i $TARGET_FILE )
        gh api --method PUT /repos/${{ inputs.owner }}/${{ inputs.repo }}/contents/$TARGET_FILE \
          --field message="$MESSAGE" \
          --field content="$CONTENT" \
          --field encoding="base64" \
          --field branch="$TARGET_BRANCH" \
          --field sha="$SHA"

    - name: Create PR and try to merge
      shell: bash
      env:
        GH_TOKEN: ${{ steps.generate-token.outputs.token }}
        LABEL_NAME: auto-deploy
        TARGET_ENV: ${{ steps.get-environment.outputs.environment }}
        TARGET_FILE: ${{ steps.find-target-file.outputs.target_file }}
        HEAD_BRANCH: update-${{ steps.get-environment.outputs.environment }}-${{ inputs.component-name }}
        IS_COMMIT: ${{ steps.commit.outputs.commit }}
      run: |
        # If the file has not changes then don't commit
        if [ $IS_COMMIT == "true" ]; then

          # do not create the PR if it already exists from the same branch
          if [[ $(gh pr list --state open --head $HEAD_BRANCH) ]]; then
            echo "PR already exists"
          else
            echo "Creating PR"
            # if the TARGET_ENV is production or staging then do not add the auto-deploy label
            if [ $TARGET_ENV == "production" ] || [ $TARGET_ENV == "staging" ]; then
              gh pr create \
              --title "chore: Update ${{ inputs.component-name }} image tag to ${{ inputs.image-tag }} in ${{ steps.get-environment.outputs.environment }}" \
              --body "This PR was automatically created by the auto-deploy action. Do not edit manually."
            else
              gh pr create \
              --title "chore: Update ${{ inputs.component-name }} image tag to ${{ inputs.image-tag }} in ${{ steps.get-environment.outputs.environment }}" \
              --body "This PR was automatically created by the auto-deploy action. Do not edit manually." \
              --label auto-deploy
            fi
          fi

        fi

        # try to merge the PR if the TARGET_ENV is dev
        if [ $TARGET_ENV == "dev" ]; then
          echo "Merging PR"
          gh pr merge --auto --merge --delete-branch
        fi
