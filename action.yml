name: "Hello World"
description: "Prints hello world"
inputs:
  owner:
    description: "Owner of the repository if it is not the current one"
    required: true
  repo:
    description: "Repository on which to udpate. Used only if you want to udpate on another repo"
    required: true
  imageTag:
    description: "The tag of the image to be udpated"
    required: true
  appId:
    description: "The id of the GitHub App"
    required: true
  privateKey:
    description: "The id of the GitHub App"
    required: true
  targetDirectory:
    description: "The directory where the image.yaml file is located"
    required: true
runs:
  using: "composite"
  steps:
    - id: generate-token
      uses: actions/create-github-app-token@v1
      with:
        app-id: ${{ inputs.appId }}
        private-key: ${{ inputs.privateKey }}
        owner: ${{ inputs.owner }}
        repositories: ${{ inputs.repo }}

    - uses: actions/checkout@v4
      with:
        repository: ${{ inputs.owner }}/${{ inputs.repo }} # Replace with the actual target repository
        token: ${{ steps.generate-token.outputs.token }} # insert the token

    - id: env
      shell: bash
      run: |
        if [[ $GITHUB_REF == refs/tags/* ]]; then
          environment=production
        elif [[ $GITHUB_REF == refs/heads/main ]]; then
          environment=staging
        else
          environment=dev
        fi
        echo "::set-output name=environment::${environment}"

    - id: component
      shell: bash
      run: |
        component=${{ inputs.targetDirectory }}
        // TODO: use the new way of set-output since the old one is deprecated
        echo "::set-output name=component::${component}"

    - id: find-target-file
      run: |
        environment=${{ steps.env.outputs.environment }}
        component=${{ steps.component.outputs.component }}
        if [ $environment == "production" ]; then
          target_file="overlays/production/image.yaml"
        elif [ $environment == "staging" ]; then
          target_file="overlays/staging/image.yaml"
        else
          target_file="overlays/development/image.yaml"
        fi
        echo "::set-output name=target_file::${target_file}"
      shell: bash

    - id: create-label
      run: |
        # Define your GitHub repository and access token
        REPO="${{ inputs.owner }}/${{ inputs.repo }}"

        # Define the label you want to check and create if it doesn't exist
        LABEL_NAME="autodeploy"
        LABEL_COLOR="00FF00"  # You can specify a color in hexadecimal format

        # Make a request to fetch the list of labels
        response=$(curl -s -H "Authorization: token ${{ steps.generate-token.outputs.token }}" "https://api.github.com/repos/$REPO/labels")

        # Check if the label exists in the response
        if [[ "$response" == *"$LABEL_NAME"* ]]; then
          echo "Label '$LABEL_NAME' exists in the repository."
        else
          echo "Label '$LABEL_NAME' does not exist in the repository. Creating it..."
          # Create the label using the GitHub API
          curl -X POST "https://api.github.com/repos/$REPO/labels" \
            -H "Authorization: token ${{ steps.generate-token.outputs.token }}" \
            -d "{\"name\":\"$LABEL_NAME\",\"color\":\"$LABEL_COLOR\"}"
          echo "Label '$LABEL_NAME' has been created."
        fi
      shell: bash

    - run: |
        environment=${{ steps.env.outputs.environment }}
        component=${{ steps.component.outputs.component }}
        branch_name="update-$component-$environment"
        target_file=${{ steps.find-target-file.outputs.target_file }}

        # Do not create a new branch if the branch already exists
        if [[ $(git ls-remote origin $branch_name) ]]; then
          git fetch origin
          git checkout $branch_name
        else
          git checkout -b $branch_name
          git push --set-upstream origin $branch_name
        fi
      shell: bash

      # Use the REST API to commit changes, so we get automatic commit signing
    - run: |
        # Update the image.yaml file with the new image tag
        echo "image:" > $TARGET_FILE
        echo "  tag: ${{ inputs.imageTag }}" >> $TARGET_FILE

        export MESSAGE="chore: Update $TARGET_FILE for to ${{ inputs.imageTag }}"
        export SHA=$( git rev-parse $DESTINATION_BRANCH:$TARGET_FILE )
        export CONTENT=$( base64 -i $TARGET_FILE )
        gh api --method PUT /repos/${{ inputs.owner }}/${{ inputs.repo }}/contents/$TARGET_FILE \
          --field message="$MESSAGE" \
          --field content="$CONTENT" \
          --field encoding="base64" \
          --field branch="$DESTINATION_BRANCH" \
          --field sha="$SHA"
      env:
        GITHUB_TOKEN: ${{ steps.generate-token.outputs.token }}
        DESTINATION_BRANCH: update-${{ steps.component.outputs.component }}-${{ steps.env.outputs.environment }}
        TARGET_FILE: ${{ steps.component.outputs.component }}/${{ steps.find-target-file.outputs.target_file }}
      shell: bash

    - run: |
        # do not create the PR if it already exists from the same branch
        if [[ $(gh pr list --state open --head $HEAD_BRANCH) ]]; then
          echo "PR already exists"
        else gh pr create \
          --body "" \
          --title "Update $component/$target_file for $environment" \
          --label autodeploy
        fi
      env:
        GH_TOKEN: ${{ steps.generate-token.outputs.token }}
        environment: ${{ steps.env.outputs.environment }}
        component: ${{ steps.component.outputs.component }}
        target_file: ${{ steps.find-target-file.outputs.target_file }}
        HEAD_BRANCH: update-${{ steps.component.outputs.component }}-${{ steps.env.outputs.environment }}
      shell: bash
